// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"sync"
	"time"
)

// ConfigMock is a mock implementation of srv.Config.
//
//	func TestSomethingThatUsesConfig(t *testing.T) {
//
//		// make and configure a mocked srv.Config
//		mockedConfig := &ConfigMock{
//			HostFunc: func() string {
//				panic("mock out the Host method")
//			},
//			IdleTimeoutFunc: func() time.Duration {
//				panic("mock out the IdleTimeout method")
//			},
//			PortFunc: func() int {
//				panic("mock out the Port method")
//			},
//			ReadHeaderTimeoutFunc: func() time.Duration {
//				panic("mock out the ReadHeaderTimeout method")
//			},
//			WriteTimeoutFunc: func() time.Duration {
//				panic("mock out the WriteTimeout method")
//			},
//		}
//
//		// use mockedConfig in code that requires srv.Config
//		// and then make assertions.
//
//	}
type ConfigMock struct {
	// HostFunc mocks the Host method.
	HostFunc func() string

	// IdleTimeoutFunc mocks the IdleTimeout method.
	IdleTimeoutFunc func() time.Duration

	// PortFunc mocks the Port method.
	PortFunc func() int

	// ReadHeaderTimeoutFunc mocks the ReadHeaderTimeout method.
	ReadHeaderTimeoutFunc func() time.Duration

	// WriteTimeoutFunc mocks the WriteTimeout method.
	WriteTimeoutFunc func() time.Duration

	// calls tracks calls to the methods.
	calls struct {
		// Host holds details about calls to the Host method.
		Host []struct {
		}
		// IdleTimeout holds details about calls to the IdleTimeout method.
		IdleTimeout []struct {
		}
		// Port holds details about calls to the Port method.
		Port []struct {
		}
		// ReadHeaderTimeout holds details about calls to the ReadHeaderTimeout method.
		ReadHeaderTimeout []struct {
		}
		// WriteTimeout holds details about calls to the WriteTimeout method.
		WriteTimeout []struct {
		}
	}
	lockHost              sync.RWMutex
	lockIdleTimeout       sync.RWMutex
	lockPort              sync.RWMutex
	lockReadHeaderTimeout sync.RWMutex
	lockWriteTimeout      sync.RWMutex
}

// Host calls HostFunc.
func (mock *ConfigMock) Host() string {
	if mock.HostFunc == nil {
		panic("ConfigMock.HostFunc: method is nil but Config.Host was just called")
	}
	callInfo := struct {
	}{}
	mock.lockHost.Lock()
	mock.calls.Host = append(mock.calls.Host, callInfo)
	mock.lockHost.Unlock()
	return mock.HostFunc()
}

// HostCalls gets all the calls that were made to Host.
// Check the length with:
//
//	len(mockedConfig.HostCalls())
func (mock *ConfigMock) HostCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockHost.RLock()
	calls = mock.calls.Host
	mock.lockHost.RUnlock()
	return calls
}

// ResetHostCalls reset all the calls that were made to Host.
func (mock *ConfigMock) ResetHostCalls() {
	mock.lockHost.Lock()
	mock.calls.Host = nil
	mock.lockHost.Unlock()
}

// IdleTimeout calls IdleTimeoutFunc.
func (mock *ConfigMock) IdleTimeout() time.Duration {
	if mock.IdleTimeoutFunc == nil {
		panic("ConfigMock.IdleTimeoutFunc: method is nil but Config.IdleTimeout was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIdleTimeout.Lock()
	mock.calls.IdleTimeout = append(mock.calls.IdleTimeout, callInfo)
	mock.lockIdleTimeout.Unlock()
	return mock.IdleTimeoutFunc()
}

// IdleTimeoutCalls gets all the calls that were made to IdleTimeout.
// Check the length with:
//
//	len(mockedConfig.IdleTimeoutCalls())
func (mock *ConfigMock) IdleTimeoutCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIdleTimeout.RLock()
	calls = mock.calls.IdleTimeout
	mock.lockIdleTimeout.RUnlock()
	return calls
}

// ResetIdleTimeoutCalls reset all the calls that were made to IdleTimeout.
func (mock *ConfigMock) ResetIdleTimeoutCalls() {
	mock.lockIdleTimeout.Lock()
	mock.calls.IdleTimeout = nil
	mock.lockIdleTimeout.Unlock()
}

// Port calls PortFunc.
func (mock *ConfigMock) Port() int {
	if mock.PortFunc == nil {
		panic("ConfigMock.PortFunc: method is nil but Config.Port was just called")
	}
	callInfo := struct {
	}{}
	mock.lockPort.Lock()
	mock.calls.Port = append(mock.calls.Port, callInfo)
	mock.lockPort.Unlock()
	return mock.PortFunc()
}

// PortCalls gets all the calls that were made to Port.
// Check the length with:
//
//	len(mockedConfig.PortCalls())
func (mock *ConfigMock) PortCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockPort.RLock()
	calls = mock.calls.Port
	mock.lockPort.RUnlock()
	return calls
}

// ResetPortCalls reset all the calls that were made to Port.
func (mock *ConfigMock) ResetPortCalls() {
	mock.lockPort.Lock()
	mock.calls.Port = nil
	mock.lockPort.Unlock()
}

// ReadHeaderTimeout calls ReadHeaderTimeoutFunc.
func (mock *ConfigMock) ReadHeaderTimeout() time.Duration {
	if mock.ReadHeaderTimeoutFunc == nil {
		panic("ConfigMock.ReadHeaderTimeoutFunc: method is nil but Config.ReadHeaderTimeout was just called")
	}
	callInfo := struct {
	}{}
	mock.lockReadHeaderTimeout.Lock()
	mock.calls.ReadHeaderTimeout = append(mock.calls.ReadHeaderTimeout, callInfo)
	mock.lockReadHeaderTimeout.Unlock()
	return mock.ReadHeaderTimeoutFunc()
}

// ReadHeaderTimeoutCalls gets all the calls that were made to ReadHeaderTimeout.
// Check the length with:
//
//	len(mockedConfig.ReadHeaderTimeoutCalls())
func (mock *ConfigMock) ReadHeaderTimeoutCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockReadHeaderTimeout.RLock()
	calls = mock.calls.ReadHeaderTimeout
	mock.lockReadHeaderTimeout.RUnlock()
	return calls
}

// ResetReadHeaderTimeoutCalls reset all the calls that were made to ReadHeaderTimeout.
func (mock *ConfigMock) ResetReadHeaderTimeoutCalls() {
	mock.lockReadHeaderTimeout.Lock()
	mock.calls.ReadHeaderTimeout = nil
	mock.lockReadHeaderTimeout.Unlock()
}

// WriteTimeout calls WriteTimeoutFunc.
func (mock *ConfigMock) WriteTimeout() time.Duration {
	if mock.WriteTimeoutFunc == nil {
		panic("ConfigMock.WriteTimeoutFunc: method is nil but Config.WriteTimeout was just called")
	}
	callInfo := struct {
	}{}
	mock.lockWriteTimeout.Lock()
	mock.calls.WriteTimeout = append(mock.calls.WriteTimeout, callInfo)
	mock.lockWriteTimeout.Unlock()
	return mock.WriteTimeoutFunc()
}

// WriteTimeoutCalls gets all the calls that were made to WriteTimeout.
// Check the length with:
//
//	len(mockedConfig.WriteTimeoutCalls())
func (mock *ConfigMock) WriteTimeoutCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockWriteTimeout.RLock()
	calls = mock.calls.WriteTimeout
	mock.lockWriteTimeout.RUnlock()
	return calls
}

// ResetWriteTimeoutCalls reset all the calls that were made to WriteTimeout.
func (mock *ConfigMock) ResetWriteTimeoutCalls() {
	mock.lockWriteTimeout.Lock()
	mock.calls.WriteTimeout = nil
	mock.lockWriteTimeout.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *ConfigMock) ResetCalls() {
	mock.lockHost.Lock()
	mock.calls.Host = nil
	mock.lockHost.Unlock()

	mock.lockIdleTimeout.Lock()
	mock.calls.IdleTimeout = nil
	mock.lockIdleTimeout.Unlock()

	mock.lockPort.Lock()
	mock.calls.Port = nil
	mock.lockPort.Unlock()

	mock.lockReadHeaderTimeout.Lock()
	mock.calls.ReadHeaderTimeout = nil
	mock.lockReadHeaderTimeout.Unlock()

	mock.lockWriteTimeout.Lock()
	mock.calls.WriteTimeout = nil
	mock.lockWriteTimeout.Unlock()
}
